## 1. Конфигурация
В состав Git входит утилита **git config**. Она позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git и его внешний вид.  
Эти параметры могут быть сохранены в трёх местах:  
* ```/etc/gitconfig```, опция ```--system```  
* ```~/.gitconfig``` или ```~/.config/git/config```, опция ```--global```  
* ```.git/config```, опция ```--local```  
  
Посмотреть все настройки и где они заданы:  
```git config --list --show-origin```

Для корректной работы репозитория, а также для того, чтобы иметь возможность установить автора внесенных изменений, необходимо представиться:  
```$ git config --global user.name "name"```  
```$ git config --global user.email example@email.com```  
  
Чтобы узнать текущие настройки (например, под какими данными мы авторизованы), можно запросить эту информацию у GIT:  
```$ git config --list```  
Данная команда выдаст все конфигурации, установленные для конкретного пользователя.  
Также есть возможность узнать конкретную настройку, например:
```$ git config user.name```
Команда выдаст информацию по запросу.  
  
Также git config позволяет изменить визуальный вывод данных - настройки интерфейса могут облегчить восприятие, например, применить выделение цветом:
```$ git config --global color.ui true```
  
  
## 2. Инициализация GIT-репозитория:  
```$ git init```  
В директории создастся подкаталог **.git**, содержащий базу GIT-репозитория.  

## 3. Загрузка файлов в GIT
Для этого необходимо добавить файлы в индекс и произвести коммит, используя команды ```git add``` и ```git commit```:  
```$ git add .```  
```$ git commit -m 'initial commit'```  
Все  файлы, находящиеся в директории, будут закоммичены. С этого момента проект находится под версионным контролем, поскольку в GIT-репозитории располагаются отслеживаемые файлы и начальный коммит.

## 4. Клонирования существующего репозитория:
Для этого используется команда ```git clone```, к которой добавляется ссылка на существующий репозиторий, а также (при  необходимости) новое имя склонированного репозитория:  
```$ git clone <https://github.com/example/repo>```
В данном случае репозиторий будет называться **repo**  
Также возможно задать другое имя для директории:  
```$ git clone <https://github.com/libgit2/libgit2> newrepo```  
В данном случае репозиторий будет называться **newrepo**  
  
## 5. Файлы в GIT  
Файлы находятся в разном состоянии в зависимости от жизненного цикла:
* untracked — неотслеживаемый 
* unmodified — неизменённый 
* modified — изменённый
* staged — зафиксированный
  
Для того чтобы определить состояние файлов используется команда ```git status```  
В **неизменённом состоянии** файлы находятся сразу после коммита, но до того, как были внесены новые изменения - то есть, когда файлы в рабочей директории соответствуют файлам, попавшим в последний коммит.  
  
Файлы переходят в **изменённое состояние** после того, как в них вносятся любые изменения, но до того, как они будут подготовлены к коммиту. Изменениями является: добавление новых файлов, изменение старых, переименование, удаление - любые действия, воздействующие на содержимое репозитория.  
  
Сообщение **Untracked files** в выводе команды ```git status``` означает, что внесенные изменения ещё не зафиксированы.  
Если какие-то файлы, отмеченные как **Untracked**, нам не нужны, достаточно просто не предпринимать никаких действий в их отношении, чтобы они не попали в следующий коммит.  
Если же мы хотим, чтобы в коммит попали нужные нам изменения, эти изменения необходимо добавить под версионный контроль, то есть, начать отслеживать и, тем самым, подготовить к коммиту.  
**Подготовленным к коммиту** (**staged**) файл становится, если после всех произошедших с ним изменений он индексируется (т.е. вносится во временное хранилище) с помощью команды ```git add```:  
```$ git add README.md```  
  
### 5.1. Вывод статуса  
Один и тот же файл может находиться одновременно в двух разных состояниях (быть одновременно **подготовленным** и **не подготовленным** к коммиту). Это происходит, если изменения в файле были проиндексированы, однако после этого в тот же файл были внесены другие изменения - в таком случае, вывод команды ```git status``` будет выглядеть так:
```
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   README.md
```
  
### 5.2. Сокращённый вывод статуса  
Если вы выполните ```git status -s``` или ```git status --short```, вы получите гораздо более упрощённый вывод:
```
$ git status -s ИЛИ git status --short
   M README – модифицирован, не индексирован
MM Namefile – модифицирован, индексирован и ещё раз модифицирован
A  etc/git.txt – добавлен в отслеживаемые 
M  etc/modern.md – модифицирован, индексирован
?? LICENSE.txt – новый неотслеживаемый
```  

### 5.3. Игнорирование  
Для того, чтобы лишние файлы не попадали в staged, необходимо создать файл **.gitignore**, в котором будет перечислено то, что будет отсеиваться автоматически:  
```
$ cat .gitignore
/tmp/
!/tmp/no-cache-data/
/.idea/
/temp/*
*.pyc
*.[oa]
/t?mp/*
*~ 
```  
В этом примере будут игнорироваться файлы, заканчивающиеся на **.о** или на **.а**, а также на **~**.  
Для формирования файла **.gitignore**, необходимо соблюдать следующие правила:  
* Используются стандартные glob-шаблоны - упрощенные регулярные выражения:
  * Символ (*) подразумевает любое количество символов,  
  * Последовательность [abc] - обозначает любой символ из перечисленных в скобках, то есть либо **a**, либо **b**, либо **c**,  
  * Символ (?) подразумевает один символ,  
  * Последовательность [a-z] - обозначает любой символ из указанного в скобках интервала, то есть все от a до z,
* Комментарии в файле **.gitignore** можно ввести, начав строку с символа #,
* (/) слэш в начале и конце строки укажет на конкретный каталог,
* (!) восклицательный знак в начале строки инвертирует шаблон: будут проигнорированы все файлы из указанного каталога, кроме тех, что отмечены восклицательным знаком,
* (/temp/*) - игнорировать все файлы директории temp, но не игнорировать подкаталоги  
  
## 7. Просмотр изменений
Команда ```git diff``` показывает, какие именно строки были удалены/добавлены. Отслеживаться с помощью ```git diff``` могут только те файлы, которые были добавлены под версионный контроль (проиндексированы).  

**Предположим у нас есть:**  
* **README.md**, который был создан и проиндексирован после последнего коммита  
* **EXAMPLE.md**, который был изменён после последнего коммита, но ещё не проиндексирован.  
Для того чтобы проследить судьбу **EXAMPLE.md** и выяснить, какие изменения были внесены, но не были проиндексированы, необходимо вызвать команду ```git diff```, в таком случае её вывод будет таким:  
```
$ git diff
diff --git a/EXAMPLE.md b/EXAMPLE.md
index 643e24f..87f08c8 100644
--- a/EXAMPLE.md
+++ b/EXAMPLE.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```  
Где ```diff --git a/EXAMPLE.md b/EXAMPLE.md``` показывает, какие именно файлы сравниваются, где **а** - версия после индексирования, **b** - текущая версия:  
```--- a/EXAMPLE.md``` - дословно читается как "из версии **а** удален файл EXAMPLE.md"  
```+++ b/EXAMPLE.md``` - дословно читается как "в версию **b** добавлен файл EXAMPLE.md"  
Вывод данной команды покажет разницу между содержимым индекса и содержимым рабочего каталога, то есть, от последнего индексирования до текущего момента.  
Команды ```git diff --staged``` и ```git diff --cached``` выполняют одно и то же действие - они показывают разницу между текущим индексом (**подготовленными изменениями**) и **последним коммитом**. Эти две команды могут использоваться взаимозаменяемо, и результат будет идентичным.  
В таком случае вывод этой команды будет выглядеть так:  
```
$ git diff --staged
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+My Project
```  
Где ```diff --git a/README b/README``` - показывает, какие именно файлы сравниваются, где **а** - версия последнего коммита, **b** - версия последнего индексирования  
```--- /dev/null``` - "удалено отсутствие файла", то есть, в предыдущем коммите данного файла не было  
```+++ b/README.md``` - в версию **b** добавлен файл README.md.
  
В случае, если проиндексированный файл **Example2.md** существовал в последнем коммите, (т.е. ```git status``` называет его не **new file**, а **modified**), вывод команды ```git diff --staged``` будет таким:  
```
$ git diff --staged
diff --git a/Example2.md b/Example2.md
index 8ebb991..643e24f 100644
--- a/Example2.md
+++ b/Example2.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's)
```  
Где **diff --git a/Example2.md b/Example2.md** - показывает, что сравниваются файлы **Example2** версии **а** (версии последнего коммита) и версии **b** (версии последнего индексирования).  
```--- a/Example2.md``` - из версии **а** извлечён файл **Example2.md** (т.е. версия этого файла из последнего коммита)  
```+++ b/Example2.md``` - в версию **b** добавлен файл **Example2.md** (т.е. новая версия этого файла, содержащаяся в последнем
индексировании).  
  
Также, если при выводе ```git status``` файл указывается одновременно как **подготовленный** и **не подготовленный** к коммиту, то есть, если файл содержит и **проиндексированные**, и **непроиндексированные** изменения вместе, то возможно просмотреть и те, и другие изменения - для этого необходимо использовать и ```git diff```, и ```git diff --staged``` (```--cached```) в зависимости от того, какие именно изменения нужно просмотреть.  
  
Чтобы выполнить git diff для определенного файла, укажите путь к этому файлу после команды git diff. Например:
```git diff path/to/your/file.txt```  
Это покажет разницу между текущей версией указанного файла в вашей рабочей директории и последним коммитом в репозитории.  
  
Если вы хотите сравнить файл между двумя конкретными коммитами, вы можете использовать следующий формат:
```git diff commit1SHA commit2SHA path/to/your/file.txt```  
  
## 8. Сброс изменений перед коммитом
Если вы случайно добавили файлы с помощью ```git add .``` и хотите отменить эту операцию перед коммитом, вы можете использовать ```git reset``` - это отменит добавление всех файлов, которые вы добавили с помощью ```git add .```. Это снимет все файлы, которые были подготовлены к коммиту.  
  
Если вы хотите отменить добавление конкретного файла, вы можете указать его имя после git reset, например:  
```git reset path/to/your/file.txt```  
После выполнения git reset, файлы будут снова находиться в вашей рабочей директории и не будут подготовлены к коммиту.  
Теперь вы можете пересмотреть изменения и, если необходимо, внести коррективы перед коммитом.  
  
Если вы хотите удалить файл из вашего репозитория и одновременно из индекса (staging area) и больше не хотите видеть его в вашем репозитории, используйте ```git rm <filename>``` 
* ```git rm -f readme``` — удалить файл, если он уже проиндексирован 
* ```git rm --cached readme``` — оставить файл на жёстком диске, но перестать отслеживать. Эта команда также снимет файл с индекса, но она также отметит файл как удаленный, и он будет удален из следующего коммита. Однако файл не будет удален из вашей рабочей директории, и вы по-прежнему сможете видеть и редактировать его локально.
* ```git rm log/\*.log``` — возможность использовать шаблоны


# 9. Коммит  
```$ git commit -m "The awesome commit"```  
Данные, которые не были проиндексированы, не добавляются в коммит и остаются в рабочем каталоге.  
  
Если вы хотите включить новые изменения в уже созданный коммит, вы можете воспользоваться командой ```git commit --amend```. Вот как это сделать:  
1. Добавьте новые изменения в файлы. Затем выполните команду git add, чтобы подготовить эти изменения к коммиту:  
```git add файлы-с-новыми-изменениями```  
2. Теперь, чтобы включить новые изменения в последний коммит, выполните команду:  
```git commit --amend```  
Это откроет текстовый редактор, где вы можете отредактировать сообщение коммита, если это необходимо. Сохраните изменения и закройте редактор.  
Если вы хотите изменить коммит сразу в командной строке без открытия редактора, вы можете использовать флаг -m для git commit --amend и передать сообщение коммита в кавычках. Вот пример: ```git commit --amend -m "Ваше новое сообщение коммита"```  
3. В результате коммит будет изменен, и в него будут включены новые изменения, а также, при желании, измененное сообщение коммита.  
Обратите внимание, что изменение коммита с помощью ```git commit --amend``` изменяет историю коммитов. Будьте осторожны при использовании этой команды, особенно если вы уже поделились своими изменениями с другими. Т.е. изменение истории коммитов с помощью git commit --amend влияет на предыдущие коммиты и создает новый коммит, который заменяет предыдущий. Это означает, что если вы изменили коммит и затем отправили его в удаленный репозиторий, другие участники, работающие с этим репозиторием, могут столкнуться с проблемами. Когда история коммитов изменяется, это означает, что SHA-хеши (уникальные идентификаторы коммитов) всех последующих коммитов также изменяются. Это может сбить с толку других участников, которые ранее скачали измененный коммит. При попытке синхронизировать свой репозиторий с удаленным репозиторием они могут столкнуться с конфликтами или проблемами с обновлением.  
    
## 10. История коммитов  
Основная команда для просмотра истории: ```git log```  
У команды ```git log``` есть очень большое количество опций для поиска коммитов по разным критериям.  
Команда ```git log -2``` выведет последние 2 коммита.  
  
**Полезные аргументы:**  
* ```--patch``` показывает разницу (выводит патч), внесённую в каждый коммит:  
```$ git log --patch -1``` (или ```git log -p -1```)  
* ```$ git log --stat -2``` отображает аналогичную информацию, но содержит разницу для каждой записи. Опция печатает под каждым из коммитов список и количество изменённых файлов, а также количество строк, которое было добавлено и удалено в каждом из файлов. В конце можно увидеть суммарную таблицу изменений  
* ```$ git log --pretty=oneline``` (или ```short```, ```full```, ```fuller```) опция --pretty меняет формат вывода  
* ```$ git log --pretty=format:"%h - %an, %ar : %s"``` опция --format позволяет указать формат для вывода данных. Опции форматирования:  
  * ```%H``` — хеш коммита
  * ```%h``` — сокращённый хеш коммита
  * ```%T``` — хеш дерева
  * ```%t``` — сокращённый хеш дерева
  * ```%P``` — хеш родителей
  * ```%p``` — сокращённый хеш родителей
  * ```%an``` — имя автора
  * ```%ae``` — электронная почта автора
  * ```%ad``` — дата автора (формат даты можно задать опцией --date=option)
  * ```%ar``` — относительная дата автора
  * ```%cn``` — имя коммитера
  * ```%ce``` — электронная почта коммитера
  * ```%cd``` — дата коммитера
  * ```%cr``` — относительная дата коммитера
  * ```%s``` — описание коммита  
* ```$ git log --shortstat``` — отображает только строку с количеством изменений/вставок/удалений для команды --stat
* ```$ git log --name-only``` — показывает список изменённых файлов после информации о коммите
* ```$ git log --name-status``` — показывает список файлов, которые добавлены/изменены/удалены
* ```$ git log --abbrev-commit``` — показывает только несколько символов чек-суммы SHA-1 вместо всех 40
* ```$ git log --relative-date``` — отображает дату в относительном формате
* ```$ git log --graph``` — отображает графы с ветвлениями
* ```$ git log --pretty``` — альтернативный формат: oneline, short, full, fuller и format (с помощью последней можно указать свой формат)
* ```$ git log --oneline``` — сокращение для одновременного использования опций --pretty=oneline --abbrev-commit  
  
**Ограничения git log:**  
* ```-(n)``` — показывает только последние n коммитов
* ```--since```, ```--after``` — показывает только те коммиты, которые были сделаны после указанной даты (например, "2007-11-11"), или же относительную дату, например "4 years 2 day 32 minutes ago"
* ```--until```, ```--before``` — показывает только те коммиты, которые были сделаны до указанной даты
* ```--committer``` — показывает только те коммиты, в которых запись committer совпадает с указанной строкой  
  
**Посмотреть данные коммита, зная его хеш:**  
```$ git show <hash_commit>``` 
  

## 11. Операции отмены
Внимание! Операции отмены — одна из редких областей GIT, где неверными действиями можно необратимо удалить результаты своей работы.  
  
### 11.1. Изменение последнего коммита  
В результате выполнения команд получится единый коммит  —  второй коммит заменит результаты первого:  
```$ git commit -m 'initial commit'```  
```$ git add forgotten_file```  
```$ git commit --amend```  
Мы можем попробовать найти старый коммит при помощи ```git show``` и ```git log```, так как на самом деле старый коммит также остался в истории.  
```git reflog``` - позволяет посмотреть коммиты, которые были сделаны локально на компьютере. Команда запоминает все ссылки, которые использовались в нашей рабочей копии.
  
Чтобы удалить из staged какой-то файл, можно воспользоваться командой: ```git restore HEAD <filename>``` либо ```git restore --staged <filename>```  
  
### 11.2. Отмена изменинй в файле  
Если решили, что не хотите сохранять свои изменения файла, то можно отменить изменения - таким образом они будут не записаны в staging area, но останутся в файле:  
```
$ git status
…
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
    modified:   README.md
```  
  
```
$ git checkout -- README.md 
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
    renamed:    README.md -> README
```
  
Команда ```git restore <filename>``` или ```git checkout <filename>``` - не только уберёт файл из staging area, но также удалит и изменения из самого файла.  
**Внимание!** Важно понимать, что ```git checkout -- <file>``` — опасная команда. Все локальные изменения в файле пропадут: GIT просто заменит его версией из последнего коммита.  
  
  
### 11.3. Удалить коммит  
* **В локальном репозиторие перед коммитом**:  
Если вы хотите удалить последний коммит, который ещё не был отправлен в удалённый репозиторий, вы можете использовать команду:  
```git reset HEAD~1```  
Эта команда сбросит HEAD на один коммит назад (**HEAD** в GIT - это указатель на последний коммит в текущей ветке. Когда вы выполняете команду git reset HEAD~1, вы фактически перемещаете указатель "HEAD" на один коммит назад, тем самым отменяя последний коммит в текущей ветке. "HEAD" указывает на текущую позицию, на которой вы находитесь в вашем репозитории. Когда вы делаете коммит, "HEAD" перемещается на новый коммит), что фактически уберет последний коммит из вашей локальной ветки. Ваши изменения останутся в рабочей директории как неотслеживаемые изменения.  
  
Если вы также хотите удалить изменения из рабочей директории, добавьте к команде флаг --hard:  
```git reset --hard HEAD~1```  
Внимание! Команда git reset --hard удалит все неотслеживаемые изменения в рабочей директории. Убедитесь, что вы не удаляете важные изменения.  
  
* **В удалённом репозиторие после коммита**:  
Внимание! Удаление коммита из удаленного репозитория может быть сложной задачей, особенно если другие участники уже скачали этот коммит и внесли изменения. Изменение истории коммитов в общем репозитории может привести к проблемам синхронизации и конфликтам.  
  
Однако, если вы уверены, что удаление коммита не вызовет серьезных проблем для других участников и вы обладаете достаточными правами доступа к удаленному репозиторию, вы можете использовать команду git push с опцией --force (или -f), чтобы принудительно отправить измененную историю коммитов на удаленный сервер. Вот как это делается:  
Вы можете использовать команду git push с опцией --force. Однако, это не фактическое удаление коммита, а его замещение новым коммитом. Другие участники репозитория должны будут внести изменения согласованно с новой историей коммитов.  
Если вы абсолютно уверены, что хотите удалить коммит из удаленного репозитория, вы можете выполнить следующие шаги:  
1. В локальном репозитории используйте команду ```git reset``` для отката локальной ветки к нужному коммиту (технически это не удалит коммит, но переместит указатель ветки): ```git reset коммит-который-нужно-удалить```  
2. Затем используйте ```git push``` с опцией ```--force```, чтобы принудительно отправить измененную историю коммитов на удаленный сервер: ```git push origin ваша-ветка --force```  
  

## 12. Удалённые репозитории  
  
### 12.1. Просмотр удалённых репозиториев  
Посмотреть их список: ```git remote```  
После клонирования как минимум один **origin**  —  имя по умолчанию. Его GIT даёт серверу, с которого производилось клонирование.
Ключ ```-v``` для более подробного вывода:  
```
$ git remote -v
origin  git@github.com:akatkinia/IT_tips.git (fetch)
origin  git@github.com:akatkinia/IT_tips.git (push)
```  
Где fetch это репозиторий для получения данных, а push для отправки данных

### 12.2. Добавление удалённых репозиториев  
Чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду ```git remote add <shortname> <url>```:  ```$ git remote add <repository_shortname> https://github.com/<user>/<repository>```  
Таким образом у нас будет подключен ещё один удалённый репозиторий к нашему локальному репозиторию, который состоит из 2 записей fetch и push.  
  
### 12.3. Fetch  
Команда **git fetch** связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет.  
После выполнения этой команды у вас появятся ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.
Чтобы получить изменение из какого-то конкретного репозитория, необходимо воспользоваться командой **fetch**:  
```git fetch <repository_shortname>```  
Таким образом GIT получит все изменения, все ветки из удалённого репозитория <repository_shortname>  
**Важно!**  
git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.  
  
### 12.4. Pull
Команда **git pull** извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (**merge**) их с кодом, над которым вы в данный момент работаете.  
  
### 12.5. Отправка изменений  
Если вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: ```git push <remote-name> <branch-name>```  
