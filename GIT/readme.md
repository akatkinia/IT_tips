## 1. Конфигурация
Для корректной работы репозитория, а также для того, чтобы иметь возможность установить автора внесенных изменений, необходимо представиться:  
```$ git config --global user.name "name"```  
```$ git config --global user.email example@email.com```

Чтобы узнать текущие настройки (например, под какими данными мы авторизованы), можно запросить эту информацию у GIT:  
```$ git config --list```  
Данная команда выдаст все конфигурации, установленные для конкретного пользователя.  
Также есть возможность узнать конкретную настройку, например:
```$ git config user.name```
Команда выдаст информацию по запросу.  
  
Также git config позволяет изменить визуальный вывод данных - настройки интерфейса могут облегчить восприятие, например, применить выделение цветом:
```$ git config --global color.ui true```
  
## 2. Инициализация GIT-репозитория:  
```$ git init```  
В директории создастся подкаталог **.git**, содержащий базу GIT-репозитория.  

## 3. Загрузка файлов в GIT
Для этого необходимо добавить файлы в индекс и произвести коммит, используя команды ```git add``` и ```git commit```:  
```$ git add .```  
```$ git commit -m 'initial commit'```  
Все  файлы, находящиеся в директории, будут закоммичены. С этого момента проект находится под версионным контролем, поскольку в GIT-репозитории располагаются отслеживаемые файлы и начальный коммит.

## 4. Клонирования существующего репозитория:
Для этого используется команда ```git clone```, к которой добавляется ссылка на существующий репозиторий, а также (при  необходимости) новое имя склонированного репозитория:  
```$ git clone <https://github.com/example/repo>```
В данном случае репозиторий будет называться **repo**  
Также возможно задать другое имя для директории:  
```$ git clone <https://github.com/libgit2/libgit2> newrepo```  
В данном случае репозиторий будет называться **newrepo**  
  
## 5. Файлы в GIT  
GIT разделяет файлы на:
* **Неотслеживаемые** - файлы не находящиеся под версионным контролем  
* **Отслеживаемые** - файлы находящиеся под версионным контролем  
  
**Отслеживаемые** файлы могут находиться в трёх состояниях: 
1. **Неизменённом**  
2. **Изменённом**  
3. **Подготовленном к коммиту**  
Для того чтобы определить состояние файлов используется команда ```git status```  
В **неизменённом состоянии** файлы находятся сразу после коммита, но до того, как были внесены новые изменения - то есть, когда файлы в рабочей директории соответствуют файлам, попавшим в последний коммит.  
  
Файлы переходят в **изменённое состояние** после того, как в них вносятся любые изменения, но до того, как они будут подготовлены к коммиту. Изменениями является: добавление новых файлов, изменение старых, переименование, удаление - любые действия, воздействующие на содержимое репозитория.  
  
Сообщение **Untracked files** в выводе команды ```git status``` означает, что внесенные изменения ещё не зафиксированы.  
Если какие-то файлы, отмеченные как **Untracked**, нам не нужны, достаточно просто не предпринимать никаких действий в их отношении, чтобы они не попали в следующий коммит.  
Если же мы хотим, чтобы в коммит попали нужные нам изменения, эти изменения необходимо добавить под версионный контроль, то есть, начать отслеживать и, тем самым, подготовить к коммиту.  
**Подготовленным к коммиту** (**staged**) файл становится, если после всех произошедших с ним изменений он индексируется (т.е. вносится во временное хранилище) с помощью команды ```git add```:  
```$ git add README.md```  
  
Один и тот же файл может находиться одновременно в двух разных состояниях (быть одновременно **подготовленным** и **не подготовленным** к коммиту). Это происходит, если изменения в файле были проиндексированы, однако после этого в тот же файл были внесены другие изменения - в таком случае, вывод команды ```git status``` будет выглядеть так:
```
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   README.md
```
  
## 6. Игнорирование  
Для того, чтобы лишние файлы не попадали в staged, необходимо создать файл **.gitignore**, в котором будет перечислено то, что будет отсеиваться автоматически:  
```
$ cat .gitignore
/tmp/
!/tmp/no-cache-data/
/.idea/
/temp/*
*.pyc
*.[oa]
/t?mp/*
*~ 
```  
В этом примере будут игнорироваться файлы, заканчивающиеся на **.о** или на **.а**, а также на **~**.  
Для формирования файла **.gitignore**, необходимо соблюдать следующие правила:  
* Используются стандартные glob-шаблоны - упрощенные регулярные выражения:
  * Символ (*) подразумевает любое количество символов,  
  * Последовательность [abc] - обозначает любой символ из перечисленных в скобках, то есть либо **a**, либо **b**, либо **c**,  
  * Символ (?) подразумевает один символ,  
  * Последовательность [a-z] - обозначает любой символ из указанного в скобках интервала, то есть все от a до z,
* Комментарии в файле **.gitignore** можно ввести, начав строку с символа #,
* (/) слэш в начале и конце строки укажет на конкретный каталог,
* (!) восклицательный знак в начале строки инвертирует шаблон: будут проигнорированы все файлы из указанного каталога, кроме тех, что отмечены восклицательным знаком,
* (/temp/*) - игнорировать все файлы директории temp, но не игнорировать подкаталоги  
  
## 7. Просмотр изменений
Команда ```git diff``` показывает, какие именно строки были удалены/добавлены. Отслеживаться с помощью ```git diff``` могут только те файлы, которые были добавлены под версионный контроль (проиндексированы).  

**Предположим у нас есть:**  
* **README.md**, который был создан и проиндексирован после последнего коммита  
* **EXAMPLE.md**, который был изменён после последнего коммита, но ещё не проиндексирован.  
Для того чтобы проследить судьбу **EXAMPLE.md** и выяснить, какие изменения были внесены, но не были проиндексированы, необходимо вызвать команду ```git diff```, в таком случае её вывод будет таким:  
```
$ git diff
diff --git a/EXAMPLE.md b/EXAMPLE.md
index 643e24f..87f08c8 100644
--- a/EXAMPLE.md
+++ b/EXAMPLE.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```  
Где ```diff --git a/EXAMPLE.md b/EXAMPLE.md``` показывает, какие именно файлы сравниваются, где **а** - версия после индексирования, **b** - текущая версия:  
```--- a/EXAMPLE.md``` - дословно читается как "из версии **а** удален файл EXAMPLE.md"  
```+++ b/EXAMPLE.md``` - дословно читается как "в версию **b** добавлен файл EXAMPLE.md"  
Вывод данной команды покажет разницу между содержимым индекса и содержимым рабочего каталога, то есть, от последнего индексирования до текущего момента.  
Команды ```git diff --staged``` и ```git diff --cached``` выполняют одно и то же действие - они показывают разницу между текущим индексом (**подготовленными изменениями**) и **последним коммитом**. Эти две команды могут использоваться взаимозаменяемо, и результат будет идентичным.  
В таком случае вывод этой команды будет выглядеть так:  
```
$ git diff --staged
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+My Project
```  
Где ```diff --git a/README b/README``` - показывает, какие именно файлы сравниваются, где **а** - версия последнего коммита, **b** - версия последнего индексирования  
```--- /dev/null``` - "удалено отсутствие файла", то есть, в предыдущем коммите данного файла не было  
```+++ b/README.md``` - в версию **b** добавлен файл README.md.
  
В случае, если проиндексированный файл **Example2.md** существовал в последнем коммите, (т.е. ```git status``` называет его не **new file**, а **modified**), вывод команды ```git diff --staged``` будет таким:  
```
$ git diff --staged
diff --git a/Example2.md b/Example2.md
index 8ebb991..643e24f 100644
--- a/Example2.md
+++ b/Example2.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's)
```  
Где **diff --git a/Example2.md b/Example2.md** - показывает, что сравниваются файлы **Example2** версии **а** (версии последнего коммита) и версии **b** (версии последнего индексирования).  
```--- a/Example2.md``` - из версии **а** извлечён файл **Example2.md** (т.е. версия этого файла из последнего коммита)  
```+++ b/Example2.md``` - в версию **b** добавлен файл **Example2.md** (т.е. новая версия этого файла, содержащаяся в последнем
индексировании).  
  
Также, если при выводе ```git status``` файл указывается одновременно как **подготовленный** и **не подготовленный** к коммиту, то есть, если файл содержит и **проиндексированные**, и **непроиндексированные** изменения вместе, то возможно просмотреть и те, и другие изменения - для этого необходимо использовать и ```git diff```, и ```git diff --staged``` (```--cached```) в зависимости от того, какие именно изменения нужно просмотреть.  
  
Чтобы выполнить git diff для определенного файла, укажите путь к этому файлу после команды git diff. Например:
```git diff path/to/your/file.txt```  
Это покажет разницу между текущей версией указанного файла в вашей рабочей директории и последним коммитом в репозитории.  
  
Если вы хотите сравнить файл между двумя конкретными коммитами, вы можете использовать следующий формат:
```git diff commit1SHA commit2SHA path/to/your/file.txt```  
  
## 8. Сброс изменений перед коммитом
Если вы случайно добавили файлы с помощью ```git add .``` и хотите отменить эту операцию перед коммитом, вы можете использовать ```git reset``` - это отменит добавление всех файлов, которые вы добавили с помощью ```git add .```. Это снимет все файлы, которые были подготовлены к коммиту.  
  
Если вы хотите отменить добавление конкретного файла, вы можете указать его имя после git reset, например:  
```git reset path/to/your/file.txt```  
После выполнения git reset, файлы будут снова находиться в вашей рабочей директории и не будут подготовлены к коммиту.  
Теперь вы можете пересмотреть изменения и, если необходимо, внести коррективы перед коммитом.  
  
# 10. Коммит  
```$ git commit -m "The awesome commit"```  
Данные, которые не были проиндексированы, не добавляются в коммит и остаются в рабочем каталоге.  
  
Если вы хотите включить новые изменения в уже созданный коммит, вы можете воспользоваться командой ```git commit --amend```. Вот как это сделать:  
1. Добавьте новые изменения в файлы. Затем выполните команду git add, чтобы подготовить эти изменения к коммиту:  
```git add файлы-с-новыми-изменениями```  
2. Теперь, чтобы включить новые изменения в последний коммит, выполните команду:  
```git commit --amend```  
Это откроет текстовый редактор, где вы можете отредактировать сообщение коммита, если это необходимо. Сохраните изменения и закройте редактор.  
Если вы хотите изменить коммит сразу в командной строке без открытия редактора, вы можете использовать флаг -m для git commit --amend и передать сообщение коммита в кавычках. Вот пример: ```git commit --amend -m "Ваше новое сообщение коммита"```  
3. В результате коммит будет изменен, и в него будут включены новые изменения, а также, при желании, измененное сообщение коммита.  
Обратите внимание, что изменение коммита с помощью ```git commit --amend``` изменяет историю коммитов. Будьте осторожны при использовании этой команды, особенно если вы уже поделились своими изменениями с другими. Т.е. изменение истории коммитов с помощью git commit --amend влияет на предыдущие коммиты и создает новый коммит, который заменяет предыдущий. Это означает, что если вы изменили коммит и затем отправили его в удаленный репозиторий, другие участники, работающие с этим репозиторием, могут столкнуться с проблемами. Когда история коммитов изменяется, это означает, что SHA-хеши (уникальные идентификаторы коммитов) всех последующих коммитов также изменяются. Это может сбить с толку других участников, которые ранее скачали измененный коммит. При попытке синхронизировать свой репозиторий с удаленным репозиторием они могут столкнуться с конфликтами или проблемами с обновлением.  
  
## 9. Удалить коммит  

* **В локальном репозиторие перед коммитом**:  
Если вы хотите удалить последний коммит, который ещё не был отправлен на удалённый репозиторий, вы можете использовать команду:  
```git reset HEAD~1```  
Эта команда сбросит HEAD на один коммит назад (**HEAD** в GIT - это указатель на последний коммит в текущей ветке. Когда вы выполняете команду git reset HEAD~1, вы фактически перемещаете указатель "HEAD" на один коммит назад, тем самым отменяя последний коммит в текущей ветке. "HEAD" указывает на текущую позицию, на которой вы находитесь в вашем репозитории. Когда вы делаете коммит, "HEAD" перемещается на новый коммит), что фактически уберет последний коммит из вашей локальной ветки. Ваши изменения останутся в рабочей директории как неотслеживаемые изменения.  
  
Если вы также хотите удалить изменения из рабочей директории, добавьте к команде флаг --hard:  
```git reset --hard HEAD~1```  
Внимание! Команда git reset --hard удалит все неотслеживаемые изменения в рабочей директории. Убедитесь, что вы не удаляете важные изменения.  
  
* **В удалённом репозиторие после коммита**:  
Внимание! Удаление коммита из удаленного репозитория может быть сложной задачей, особенно если другие участники уже скачали этот коммит и внесли изменения. Изменение истории коммитов в общем репозитории может привести к проблемам синхронизации и конфликтам.  
  
Однако, если вы уверены, что удаление коммита не вызовет серьезных проблем для других участников и вы обладаете достаточными правами доступа к удаленному репозиторию, вы можете использовать команду git push с опцией --force (или -f), чтобы принудительно отправить измененную историю коммитов на удаленный сервер. Вот как это делается:  
Вы можете использовать команду git push с опцией --force. Однако, это не фактическое удаление коммита, а его замещение новым коммитом. Другие участники репозитория должны будут внести изменения согласованно с новой историей коммитов.  
Если вы абсолютно уверены, что хотите удалить коммит из удаленного репозитория, вы можете выполнить следующие шаги:  
1. В локальном репозитории используйте команду ```git reset``` для отката локальной ветки к нужному коммиту (технически это не удалит коммит, но переместит указатель ветки): ```git reset коммит-который-нужно-удалить```  
2. Затем используйте ```git push``` с опцией ```--force```, чтобы принудительно отправить измененную историю коммитов на удаленный сервер: ```git push origin ваша-ветка --force```  
