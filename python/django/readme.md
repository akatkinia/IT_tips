## Модель MTV
Django основан на модели MTV - Model, Template, View. Где:  
* Model - Модель, то есть данные из БД
* Templates - Внейшний вид представления информации, предопределённая структура html-документа
* View - Представление, которое формирует полноценный html-документ на основе данных из Model и Template  
  
Т.е. когда пользователь обращается по определённому URL, происходит определённый маршрут до определённого ресурса, который получается благодаря модели MTV и отдаётся пользователю в ответ на его запрос.  
  
В идеалогии Django, каждая самостоятельная часть сайта должна представляться в виде отдельного приложения (например основное приложение и форму).  
  
## Структура проекта
```yaml
<папка_проекта>
  <пакет_конфигурация> # называется также как и проект
    __init__.py
    asgi.py
    settings.py
    urls.py
    wsgi.py
  db.sqlite3 # файл базы данных (по умолчанию sqlite3)
  manage.py # через него будут применяться команды применительные к текущему проекту
```  
  
## Основные команды
* ```django-admin startproject <name_of_project>``` - создать проект
* ```python .\manage.py runserver``` - выполняется в каталоге нашего проекта. Запускает веб-сервер для отладки нашего сайта
* ```python .\manage.py startapp <name_of_app>``` - создать приложение в нашем проекте  
  
## Создание приложения
* ```python .\manage.py startapp <name_of_app>``` - создать приложение в нашем проекте  
  
После создания нового приложения, мы увидим следующую структуру:  
```yaml
<папка_приложения>
  <migrations> # папка для хранения миграций нашего приложения
    __init__.py # это нам говорит, что приложение реализуется как пакет языка python
  __init__.py
  admin.py # для настройки админ панели сайта
  apps.py # для настройки конфигурирования текущего приложения
  models.py # для хранения ORM моделей для взаимодействия с БД
  tests.py # модуль с тестирующими процедурами
  views.py # для хранения представлений текущего приложения
```
  
После создания приложения, его необходимо зарегистрировать, чтобы Django знал о его существовании.  
Для этого необходимо в папке конфигурации в файле settings.py в коллекции INSTALLED_APPS добавить в виде строки имя нашего приложения (имя папки) и путь до класса <appname>Config из файла apps.py (например, ```women.apps.WomenConfig```). Но можно ограничиться и простым указанием имени приложения.  
  
## Маршрутизация и функции представления
Создадим обработчик своей собственной главной страницы. Этот обработчик будет размещён в нашем приложении women.  
Для этого откроем файла views.py и пропишем представление в виде функции (можно также в виде классов), которая будет формировать внешний вид главной страницы сайта:  
```python
from django.http import HttpResponse
from django.shortcuts import render

def index(request): # request - ссылка на специальный класс HttpRequest и содержит информацию о запросе - сессии, куках и тд    
    return HttpResponse('Страница приложения women') # возвращает экземпляр класса HttpResponse, который автоматически формирует заголовок ответа

def categories(request):
    return  HttpResponse('<h1>Статьи по категориям</h1>')
```
Теперь нужно связать эту функцию с соответствующим url адресом. Для этого в папке пакета конфигурации отредактируем файл **urls.py** (в этом файле описываются различные маршруты):  
```python
from django.contrib import admin
from django.urls import path
# from women.views import index, categories
from women import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.index), # суффикс и функция представления (в нашем случае index, которую описали в women/views.py)
    path('cats', views.categories),
]
```  
Теперь нам доступны страницы из файла маршрутов (urls.py).  
  
## Динамические URL.
Для реализации необходимо в urls.py указать например:  
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index), # суффикс и функция представления (в нашем случае index, которую описали в women/views.py)
    path('cats/<int:cat_id>/', views.categories),
]
```  
После чего в views.py для функции categories указать:  
```python
def categories(request, cat_id):
    return  HttpResponse(f'<h1>Статьи по категориям</h1><p>id: {cat_id}</p>')
```  
Таким образом была создана и использована дополнительная целочисленная переменная cat_id, которая передаётся в функцию вторым аргументом.  
  
Какие конвертеры кроме int можно ещё использовать? - https://docs.djangoproject.com/en/4.2/topics/http/urls/#path-converters  
Также можно создавать свои конвертеры (описано в той же статье, создадим для этого файл converters.py и импортируем его в urls.py. Также нужно не забыть зарегистировать этот конвертер через функцию register_converter).  
  
Также можно использовать regex через re_path, например:  
```python
    re_path(r"^archive/(?P<year>[0-9]{4})/", views.archive) # тоже что и path, но с возможностью использования regex
```  
Где символ P используется для определения именованных групп. Именованные группы позволяют именовать части регулярного выражения, что делает код более читаемым и понятным.  

## Templates  
Документация https://docs.djangoproject.com/en/4.2/topics/templates/    
Кодировка в templates должны быть обязательно в UTF-8  
Шаблоны размещать в директории templates самого приложения и подкаталоге по имени приложения, например ```woman/templates/women/index.html```  
Настраиваются шаблоны в коллекции TEMPLATES файла settings.py  
  
Чтобы шабланизировать наш html документ, необходимо в {{ }} указать нужную нам переменную, например title: ```{{ title }}```  
После чего, необходимо в функции представления (views.py) в требуемой функции создать словарь-коллекцию с переменными. Например: ```data = {'title': 'Главная страница'}```. И остаётся лишь передать этот словарь как контекст в функции render (например: ```return render(request=request, template_name='women/index.html', context=data)```)  
В шаблон (словарь контекста) могут передаваться различные типы данных такие как например dict, set, float, obj и т.д.  
Обращение по индексу объекта в списке или к ключу объекта словаря, а также к локальному объекту в классе необходимо через точку, например ```lst.0```, ```dict.key1```, ```obj.a```.  
  
### Filters
Фильтры шаблонов в документации https://docs.djangoproject.com/en/4.2/ref/templates/builtins/  
Пример шаблона, где мы прибавляем к числу ещё какое-то число (в нашем случае это переменная со значением типа данных float, и прежде чем фильтр прибавит число, он сначала преобразует исходное значение в int, так как работает только с целочисленными числами), например ```<p1>{{ float|add:'50' }}</p1>```. Где add это название функции, а её значение указывается через двоеточие.  
  
Фильтры также можно использовать вне шаблонов, просто в python приложении, для этого необходимо импортировать требуемый фильтр и затем использовать его как функцию. Например:  
```python
from django.template.defaultfilters import slugify

text = 'the main page'
slugify(text)
```  
  
### Теги
Синтаксис записи тегов ```{% название тега [параметры] %```  

#### for
Просматривает каждый элемент массива, делая элемент доступным в переменной контекста.  
Например, чтобы отобразить список спортсменов, указанный в athlete_list:  
```python
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>
```  
Вы можете перебрать список в обратном порядке, используя ```{% for obj in list reversed %}```
  
Если вам нужно перебрать список списков, вы можете распаковать значения в каждом подсписке в отдельные переменные.  
Например, если ваш контекст содержит список координат (x,y) под названием points, вы можете использовать следующее для вывода списка точек:  
```python
{% for x, y in points %}
    There is a point at {{ x }},{{ y }}
{% endfor %}
```  
  
Это также может быть полезно, если вам нужно получить доступ к элементам словаря.  
Например, если ваш контекст содержит словарь data, следующее будет отображать ключи и значения словаря:  
```python
{% for key, value in data.items %}
    {{ key }}: {{ value }}
{% endfor %}
```  
  
Учтите, что при использовании точечного оператора при поиске ключа в словаре будет иметь приоритет по сравнению с поиском метода.  
Поэтому, если словарь содержит ключ с именем 'items', вызов data.items вернет data['items'] вместо вызова метода data.items().  
Избегайте добавления ключей, которые названы так же, как методы словаря, если вы хотите использовать эти методы в шаблоне (items, values, keys и т. д.).  
  
Цикл for устанавливает ряд переменных, доступных внутри цикла:  
| Переменная         | Описание                                               |
|--------------------|--------------------------------------------------------|
| forloop.counter    | Текущая итерация цикла (с индексом 1)                  |
| forloop.counter0   | Текущая итерация цикла (с индексом 0)                  |
| forloop.revcounter | Количество итераций от конца цикла (индексировано 1)   |
| forloop.revcounter0| Количество итераций от конца цикла (с индексом 0)      |
| forloop.first      | Истинно, если это первый раз в цикле                   |
| forloop.last       | Истинно, если это последний раз в цикле                |
| forloop.parentloop | Для вложенных циклов это цикл, окружающий текущий      |  
  
#### if
Пример использования:  
```python
<ul>
    {% for p in posts %}
    {% if p.is_published %}
      <li>
          <h2>{{ p.title }}</h2>
          <p>{{ p.content}}</p>
          {% if not forloop.last %}
          <hr>
          {% endif %}
      </li>
    {% endif %}
    {% endfor %}
</ul>
```
  
#### url
Тег url работает аналогично функции reverse.  
```reverse('post', args=(11, ))``` - даёт в результате /post/11/  
```{% url 'post' 11 %}``` - также даст в результате /post/11/  
Тег помогает избавиться от хардкодинга и использовать пути, которые составляются через urls.py по имени маршрута.  
Пример использования:  
```<p><a href="{% url 'post' p.id %}">Читать пост</a></p>```  
  
### Наследование шаблонов (extends)
Базовый шаблон создаётся на уровне всего проекта в каталоге templates. В нём создадим файл base.html.  
В settings.py в коллекции TEMPLATES, в DIRS указать нестандартный путь до base.html: ```BASE_DIR / 'templates',```  
Теперь в base.html можно использовать тег {% block %}, который позволяет использовать информацию из дочерних шаблонов.  
Пример:  
```python
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ title }}</title>
</head>
<body>
{% block content %}
{% endblock %}
</body>
</html>
```  
В то время как в about.html:  
```python
{% extends 'base.html' %}
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}
```

Используя теги block и extends мы можем избежать дублирования информации. Таким образом в about.html находится только нужная уникальная информация, а в шаблоне base.html находится общая информация для всех страниц сайта.  
  
Помимо расширения базовых шаблонов, мы также можем включать этот же шаблон в другой. Для этого используется тег include, например ```{% include 'women/include/nav.html' %}```.  
Для этого по следующему пути ```/sitewomen/women/templates/women/includes/nav.html``` создадим файл, в котором будет находиться нужная нам информация.  
Теперь мы можем использовать тег в нашем файле (например index.html): ```{% include 'women/includes/nav.html' %}```  
  
### Подключение к статических файлов к шаблонам  
Когда наш проект работает в режиме отладки (DEBUG True), статика будет искаться по стандартному пути в подкаталоге static нашего приложения, а также во всех каталогах static внешних модулей (например, админки).  
В режиме эксплуатации (DEBUG False), статика будет искаться в каталоге static, расположенном в корне самого проекта.  
Для того чтобы переместить все файлы статики в каталог static в корень проекта, необходимо выполнить команду ```python manage.py collectstatic```  
  
Для подключения статических файлов, в пакете конфигураций необходимо определить три переменные в файле settings.py:  
* ```STATIC_URL``` - префикс URL-адреса для статических файлов
* ```STATIC_ROOT``` - путь к общей статической папке, формируемой при запуске команды collectstatic (для сбора всей статики в единый каталог при размещении сайта на реальном веб-сервере)
* ```STATICFILES_DIRS``` - список дополнительных (нестандартных) путей к статическим файлам, используемых для сбора и для режима отладки  
  
Для включения статики в шаблоне, необходимо её подключить с помощью тега ```{% load static %}```  
Теперь можно подключать статические файлы. Для этого указываем тег в следующем формате {% static '<путь к файлу папки static>' %}. Например: ```<link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet" />```  
  
При выключенном DEBUG режиме чтобы всё равно загружать и отображать статику из каталога static, необходимо запускать сервер через команду со следующим флагом ```python .\manage.py runserver --insecure```  

## Базы данных
MTV (**Models**, Templates, View).  
Модель отвечает за хранение и оперирование данными сайта.  
  
ORM:
  Класс - таблица БД  
  Объект класса - запись из таблицы БД  
  
Пример определения модели:  
```python
class Women(models.Model):
    title = models.CharField(max_length=255) # max_length позволяет указать длину строки
    content = models.TextField(blank=True) # blank позволяет не задавать значения поля когда создаётся новая запись
    time_create = models.DateTimeField(auto_now_add=True) # auto_now_add автоматически заполняет поле, но только в момент первого появления записи
    time_update = models.DateTimeField(auto_now=True) # auto_now автоматически меняется если меняется текущая запись
    is_published = models.BooleanField(default=True) # default по умолчанию статья будет опубликована
```  
Последовательность полей в таблице будет такой же, в какой они были определены при определении модели  
Возможные классы для типов данных и их параметры можно увидеть в документации https://docs.djangoproject.com/en/4.2/ref/models/fields  
  
Для того чтобы таблицы появились в БД (сама БД задаётся в коллекции DATABASES в settings.py) необходимо использовать технику миграции.  
Необходимо создать файл-миграции и выполнить его, который создаёт новую таблицу или меняет уже существующие данные в БД.  
  
Файлы миграции создаются автоматически. Когда мы в приложении определили модель и создаём миграции, то файлы миграции пояляются в папке "migrations" каждого приложения.  
Файлы миграции описывают новые текущие изменения (структура таблиц БД и связи между ними) - каждый новый файл миграции можно воспринимать как контроллер версии, и мы можем всегда откатиться назад.  
  
Для создания файла миграции необходимо выполнить команду ```python manage.py makemigrations```. Он будет создан в подкаталоге 'migrations' нашего приложения.  
Также можно посмотреть какой sql-запрос будет выполняться при создании новой таблицы: ```python manage.py sqlmigrate <app_name> <number_of_migration_file>```. Например:
```python
python manage.py sqlmigrate women 0001
```  
В нашем случае мы видим следующий вывод:  
```sql
BEGIN;
--
-- Create model Women
--
CREATE TABLE "women_women" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(255) NOT NULL, "content" text NOT NULL, "time_create" datetime NOT NULL, "time_update" date
time NOT NULL, "is_published" bool NOT NULL);
COMMIT;
```  
  
Теперь, для того чтобы таблицы БД были созданы, необходимо применить созданный файл-миграций: ```python manage.py migrate```  
  
Для демонстрации работы с ORM можно перейти в консоль Django: ```python manage.py shell```. В данной оболочке фреймворка Django доступны все описанные модели и команды самого фреймворка.  
Таким образом попробуем выполнить следующие команды:  
```python
from women.models import Women # импортируем модель Women

Women(title='Анджелина Джоли', content='Биография Анджелины Джоли') # Создаём новый объект класса Women для того чтобы сделать новую запись в таблице. Однако, в Django модели являются ленивыми. И создание экземпляра класса не добавляет запись в таблицу фактически.
w1 = _ # в объект w1 записываем то, что было получено в результате последней выполненной операции
w1.save() # выполняем метод save для этой модели Women, таким образом создав запись в таблице БД
w1.title # по данному атрибуту объекта мы можем обратиться к столбцу title. Таким же образом мы можем обратиться и к любому другому столбцу
w1.pk # primary key (тоже что и id)

from django.db import connection # необходимо для того чтобы посмотреть какие sql-запросы выполнялись
connection.queries # получить список из sql-запросов
connection.queries[-1] # получить последний выполненный sql-запрос

w2 = Women(title='Энн Хэтэуей', content='Биография Энн Хэтэуэй') # создадим новый экземпляр класса с новой записью
w2.save() # выполним метод для создания записи в таблице

w3 = Women()
w3.title = 'Джулия Робертс'
w3.content = 'Биография Джулия Робертс'
w3.save()
```  
Для удобства работы с оболочкой Django рекомендуется установить в наше venv также пакет ipython.  
Для упрощения работы с ORM-командами в консоли рекомендуется установить пакет django-extensions (https://github.com/django-extensions/django-extensions). Необходимо не забыть подключить установленный пакет прописав его в коллекцию INSTALLED_APPS (в settings.py)  
Теперь, выполнив команду ```python .\manage.py shell_plus --print-sql```, и в этой оболочке мы можем автоматически видеть sql-запрос, который будет выполняться для ORM-команд  
  
Также мы можем воспользоваться менеджером записей (так как Women.objects ссылается на django.db.models.manager.Manager) и создать запись в БД таким образом ```Women.objects.create(title='Ума Турман', content='Биография Умы Турман')```.  
Команда ```Women.objects.all()``` позволяет выбирать все записи, имеющиеся в текущей таблице. В результате мы получим объект QuerySet (коллекцию объектов модели, которая возвращается после выполнения запроса к БД), который содержит все наши записи.  
Команда ```Women.objects.filter(title='Энн Хэтэуей')``` не будет проходить по всем записям таблицы, а отберёт необходимую по указанному критерию. Ищется полное соответствие  
Команда ```Women.objects.filter(title__contains='ли')``` если требуется найти по вхождению, а не полному соответствию (используется django field lookup 'contains', подробнее можно найти в документации https://docs.djangoproject.com/en/4.2/ref/models/querysets/)  
Если же нужно выполнить тоже самое но без учёта регистра, необходимо использовать lookup 'icontains' - ```Women.objects.filter(title__icontains='лИ')```, но сама sqllite не позволяет искать в регистронезависимом виде  
Команда ```Women.objects.filter(pk__in=[2, 5, 11, 12], is_published=1)``` - отбирает записи, которые имеют указанные значения и при этом чтобы записи были публикованы  
  
Команда ```Women.objects.exclude(pk=2)``` - исключает записи по указанному критерию (возвращает список QuerySet) 
Команда ```Women.objects.get(pk=2)``` - возвращает только одну запись. Однако, при несуществующих указанных критериях будет вызвана ошибка, т.е. метод get генерирует исключение  

