# Жадный алгоритм (Greedy)

# Жадный алгоритм (Greedy Algorithm) - это метод решения задач, который выбирает наилучший вариант на каждом шаге, не обращая внимания на последствия этого выбора для будущих шагов. Он принимает локально оптимальное решение на каждом этапе, с надеждой, что это приведет к глобально оптимальному решению. Жадные алгоритмы хорошо работают в задачах оптимизации, где необходимо найти максимум или минимум некоторой целевой функции.

# Пример жадного алгоритма: Задача о сдаче с минимальным количеством монет.
# Предположим, у вас есть сумма денег, которую вы должны дать в виде сдачи, и есть несколько видов монет разного достоинства (например, 1, 5, 10, 25 центов). Ваша задача - дать сдачу с минимальным количеством монет.

# Жадный алгоритм для этой задачи будет следующим:
#     Начните с пустой сдачи.
#     На каждом шаге выбирайте самую большую доступную монету и добавляйте ее к сдаче до тех пор, пока сумма сдачи не станет равной или больше суммы, которую вы должны дать в сдаче.
#     Если сумма сдачи стала равной сумме, которую нужно дать в сдаче, алгоритм завершается.

# Этот жадный алгоритм обеспечивает оптимальное решение в данной задаче, так как на каждом шаге мы выбираем наибольшую доступную монету, и это минимизирует количество монет, необходимых для сдачи.
# Жадные алгоритмы могут применяться в различных задачах, но важно помнить, что они не всегда обеспечивают оптимальное решение во всех сценариях. В некоторых случаях жадный выбор может привести к недопустимым результатам, поэтому важно тщательно анализировать задачу перед использованием жадного алгоритма.


#######################################################################

# def find_minimum_coins(change_amount, coin_values):
#     # Создаем список для хранения количества монет каждого достоинства
#     coin_count = [0] * len(coin_values)
    
#     # Сортируем достоинства монет в порядке убывания
#     coin_values.sort(reverse=True)
    
#     for i in range(len(coin_values)):
#         while change_amount >= coin_values[i]:
#             change_amount -= coin_values[i]
#             coin_count[i] += 1
    
#     return coin_count

# # Пример использования
# if __name__ == "__main__":
#     # Достоинства монет
#     coin_values = [25, 10, 5, 1]  # 25 центов, 10 центов, 5 центов, 1 цент
    
#     # Сумма сдачи
#     change_amount = 63  # 63 цента
    
#     # Вычисляем минимальное количество монет для сдачи
#     coin_count = find_minimum_coins(change_amount, coin_values)
    
#     # Выводим результат
#     for i in range(len(coin_values)):
#         if coin_count[i] > 0:
#             print(f"{coin_count[i]} монет(а) по {coin_values[i]} центов")

#######################################################################

# У Олега в банке есть n евро. Он хочет снять всю сумму наличными. Номиналы еврокупюр равны 1, 5, 10, 20, 100. Какое минимальное число купюр должен получить Олег после того, как снимет все деньги? На вход программе поступает одно положительные целое число n.

n = 476

k_100 = n // 100
n = n % 100
k_20 = n // 20
n = n % 20
k_10 = n // 10
n = n % 10
k_5 = n // 5
n = n % 5
k_1 = n // 1
n = n % 1

print(k_100 + k_20 + k_10 + k_5 + k_1)

#################################################################

# ещё одно решение

n = 476

k = n // 100
n = n % 100
k = k + n // 20
n = n % 20
k = k + n // 10
n = n % 10
k = k + n // 5
n = n % 5

print(k + n)

#################################################################

# ещё одно решение

n = 476
j = 0

for i in [100, 20, 10, 5]:
    j = j + n // i
    n = n % i
print(j + n)