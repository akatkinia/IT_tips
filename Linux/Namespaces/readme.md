## Описание
Namespace в контексте операционных систем и виртуализации - это механизм, который изолирует ресурсы и имена внутри системы, позволяя разным процессам видеть свои собственные версии этих ресурсов, даже если они используют те же имена. Это позволяет создавать окружения, в которых процессы могут работать изолированно друг от друга.

## Виды namespace в Linux:
* UTS (Unix Timesharing System) namespace - это один из видов пространств имён в Linux, который изолирует системные идентификаторы хоста и домена, такие как имя узла и доменное имя. Это включает в себя параметры, такие как hostname и domainname. Использование UTS namespace позволяет процессам внутри этого пространства имён иметь свои собственные уникальные имена хоста и домена, даже если они работают на одном физическом хосте.
* PID Namespace: Изолирует пространство идентификаторов процессов. Процессы в разных PID namespaces видят разные наборы процессов, и каждый процесс имеет свой уникальный идентификатор (PID).
* Mount Namespace: Изолирует файловую систему и точки монтирования. Процессы в разных Mount namespaces видят разные наборы монтированных файловых систем.
* Network Namespace: Изолирует сетевые ресурсы, такие как сетевые интерфейсы, маршруты, таблицы ARP и т.д. Процессы в разных Network namespaces имеют свои собственные сетевые конфигурации.
* IPC Namespace: Изолирует межпроцессное взаимодействие (IPC) ресурсы, такие как семафоры, очереди сообщений и разделяемая память.
* User Namespace: Изолирует идентификаторы пользователя и группы. Процессы в разных User namespaces могут иметь свои собственные пользовательские идентификаторы.
<br>
Пространства имён позволяют создавать изолированные и контролируемые окружения для процессов, что полезно для виртуализации, контейнеризации и обеспечения безопасности.

## Cgroups
Cgroups, или "Control Groups", это механизм в ядре Linux, который позволяет управлять и ограничивать ресурсы, использованные процессами и группами процессов. Cgroups обеспечивают изоляцию и контроль над различными ресурсами, такими как CPU, память, дисковый ввод/вывод (I/O), сетевые ресурсы и др.  
  
Основные цели cgroups:
* Ограничение ресурсов: Cgroups позволяют ограничивать использование ресурсов, таких как процессорное время, память, пропускная способность диска и сети. Это помогает предотвратить ситуации, когда один процесс или контейнер занимает все доступные ресурсы, негативно влияя на другие процессы или контейнеры.
* Изоляция процессов: Cgroups обеспечивают изоляцию между процессами и группами процессов. Это позволяет создавать контролируемые окружения, такие как контейнеры, где каждый контейнер может иметь свои собственные ресурсы и не влияет на другие контейнеры.
* Приоритеты и управление: Cgroups позволяют задавать приоритеты и ограничения для разных групп процессов. Это полезно, чтобы гарантировать, что важные процессы или сервисы получают необходимые ресурсы.

### Примеры субсистем cgroups включают:
- cpu: Управление процессорным временем.
- memory: Ограничение использования оперативной памяти.
- blkio: Управление дисковым вводом/выводом.
- net_cls: Управление сетевыми ресурсами с помощью маркировки пакетов.
- net_prio: Управление сетевыми ресурсами с помощью приоритетов.
- devices: Контроль доступа к устройствам.
- cpuacct: Учет использования процессорного времени.
- freezer: Замораживание и размораживание групп процессов.
- cpuset: Ограничение доступных процессорных ядер и устройств.
- pids: Ограничение количества процессов.
- hugetlb: Управление использованием больших страниц памяти.
- perf_event: Ограничение счетчиков производительности.
- systemd: Интеграция с systemd для контроля cgroups из системного менеджера.
- rdma: Управление ресурсами RDMA (Remote Direct Memory Access).


Cgroups широко используются для контейнеризации, виртуализации и обеспечения стабильности и безопасности системы. Они позволяют администраторам эффективно управлять ресурсами и изолировать приложения, чтобы они работали стабильно и без влияния на другие части системы.

## Примеры работы с namespaces
* Вход в UTS (Unix Timesharing System) namespace:
1. Допустим мы запустили docker-контейнер <code>docker run -d --hostname c1 --name test python:alpine sleep 5000</code>.  
2. Узнаем PID процесса с нашим контейнером <code>docker inspect test | grep -i pid</code>  
3. Войдём внаш UTS namespace <code>sudo nsenter --target 2180 --uts</code>, где target это pid нашего процесса. Таким образом мы попали частично в окружение контейнера, так как нам доступно только UTS пространство имён, но не все остальные - например hostname будет равен hostname в контейнере, но сеть будет хостовой машины.  
  
* Вход в Network и Mount namespaces:
1. Допустим мы запустили docker-контейнер <code>docker run -d --hostname c1 --name test python:alpine sleep 5000</code>.  
2. Узнаем PID процесса с нашим контейнером <code>docker inspect test | grep -i pid</code>  
3. Вход в namespace <code>sudo nsenter --target 2180 --net --mount</code>, где target это pid нашего процесса. Таким образом мы попали частично в окружение контейнера, так как нам доступно только UTS пространство имён, но не все остальные - например hostname будет равен hostname хостовой машины, но сеть и файловая система будут теми, что принадлежат контейнеру.  
  
* Посмотреть cgroups определённого контейнера с pid 2180:
1. Вывести список всех субсистем cgroups контейнера <code>cat /proc/2108/cgroup</code>. Здесь мы видим также и пути до cgroup контейнера, где подкаталог это CONTAINER ID  
2. Например, мы можем посмотреть memory limit контейнера в байтах: <code>cat /sys/fs/cgroup/memory/docker/<CONTAINER_ID></code>/memory.limit_in_bytes</code>  
Но также мы можем задать лимиты для контейнера при его запуске: <code>docker run -d --memory 4m --name test2 python:alpine sleep 5000</code>  
Теперь при попытке посмотреть memory limit нашего контейнера через его cgroup memory: <code>cat /sys/fs/cgroup/memory/docker/<CONTAINER_ID>/memory.limit_in_bytes</code>, мы увидим 4194304, что равняется 4мб в байтах.
