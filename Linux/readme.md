# 1. Базовые понятия файловой структуры
Linux построен на **FHS (Flesystem Hierarchy Standard)**.  
  
**Особенности Filesystem Hierarchy Standard (FHS):**  
* Единый корень для всей файловой системы - ```/```.
* Все директории в дереве расположены относительно корня.
* Стандарт FHS включает такие директории, как ```/bin```, ```/sbin```, ```/etc```, и другие, обеспечивая системное управление файлами.
* Многие директории имеют интуитивно понятные названия. Например:
  * ```/home``` предназначена для домашних каталогов пользователей.
  * ```/root``` служит домашним каталогом для учетной записи администратора.
  * ```/tmp``` предназначена для временных файлов.
  
# 2. Переменные окружения
В момент запуска терминала, переменные окружения сохраняются в оперативной памяти. Некоторые из них могут храниться **на уровне сессии**,а другие на **уровне всего времени выполнения (runtime) операционной системы** - это зависит от того как эти переменные будут объявлены.  
  
```env``` - вывести список текущих переменных окружения и их значения. Также, команда может помочь выполнить другую команду в измененном окружении или установить временные переменные среды. Например, команда ```env VAR1=value VAR2=value <command> <arg1> <arg2>``` выполняет команду <command> с временно измененным окружением, где переменные **VAR1** и **VAR2** установлены в соответствующие значения, и передает <arg1> и <arg2> в качестве аргументов этой команде.
  
**Объявление переменных:**  
* ```testenv='hello world'``` - создать переменную **testenv** со значением **hello world**. При объявлении переменной данным способом, она будет доступна только **на уровне сессии** в текущем процессе оболочки.
* ```export testenv='hello world'``` - также создаёт переменную **testenv** со значением **hello world**. Но делает ее доступной для всех дочерних процессов текущего процесса оболочки. Таким образом, переменная будет доступна в подпроцессах, которые могут быть созданы из текущего скрипта или сеанса оболочки. Однако, если открыть новую оболочку не связанную с той, в рамках которой была создана переменная - она также не будет доступна.
* Чтобы сделать переменную всегда доступной, вы можете добавить объявление переменной с использованием ```export``` в ваш файл настройки оболочки - например, в ```.bashrc``` или ```.bash_profile```. При каждом запуске новой сессии оболочки или подпроцесса эти файлы читаются, и переменные, определенные с использованием **export**, становятся доступными для этих процессов.  
* Файл ```/etc/environment``` используется для установки глобальных переменных среды, доступных для всех пользователей и процессов в системе. В отличие от файлов настройки оболочки (например, **.bashrc** или **.profile**), которые применяются к каждой сессии пользователя, **/etc/environment** устанавливает переменные среды на более общем уровне, доступном для всех пользователей и процессов. После внесения изменений в файл **/etc/environment**, для их активации следует выполнить одно из следующих действий:
  * Перезапустите систему
  * Выйдите из текущей сессии и войдите в неё заново
  * Используйте команду ```source```: Выполните команду ```source /etc/environment``` в текущей оболочке. Это применит изменения из файла к текущей сессии.
* Также, в bash-скриптах зачастую используется команда ```read <variable_name>``` для считывания данных с ввода пользователя или другого потока данных и присваивания их переменной (ожидается взаимодействие от пользователя/программы на ввод и это значение передаётся в переменную).  
Пример использования команды **read** в bash-скрипте:  
```bash
echo "1 2 3" | while read a b c; do
    echo "Переменные: a = $a, b = $b, c = $c"
done
```  
Также может использоваться в циклах для чтения строк из файла: например, в циклах для построчного чтения данных из файла:  
```bash
while read line; do
    echo "Прочитанная строка: $line"
done < filename.txt
```  
В этом примере **read** используется для построчного чтения строк из файла **filename.txt** в цикле. В данном случае комнада ```read line``` будет считывать строку из входного потока и присваивать ее переменной **line**.  
  
В файле **/etc/environment** задана переменная **PATH**, в которой находятся т.н. "пути поиска" по которым shell ищет исполняемые бинарные файлы по путям указанным в данной переменной. Поиск происходит поочередной с первой директории и далее.
  
# 3. Типы команд  
В Linux команды деляться на три типа: **Встроенные функции**, **ключевые слова** и **программы**  
Команда ```type``` поможет разобраться к какому типу относится каждая из команд. Например:  
```bash
root@server:~# type echo
echo is a shell builtin     # Встроенная функция оболочки
root@server:~# type whoami
whoami is /usr/bin/whoami   # Программа
root@server:~# type {
{ is a shell keyword        # Ключевое слово
```  
Фигурные скобки ```{}``` могут использоваться для создания блока команд, который может быть выполнен внутри цикла или конструкции управления потоком (например, с использованием **for** или **while**). Открывающая фигурная скобка **{** и соответствующая ей закрывающая фигурная скобка **}** формируют блок кода, который будет выполнен вместе.  
**Пример использования фигурных скобок в конструкции цикла for:**  
```bash
for i in {1..5}
do
  echo "Number $i"
done
```  
  
# 4. Алиасы
* ```alias <alias_name> = "<command>"``` - алиасы задаются следующим образом
* ```alias``` - посмотреть список всех доступных алиасов


# 5. Полезные команды

* ```netstat -ntlp``` - для отображения списка активных сетевых соединений и слушающих портов на компьютере. Расшифровка опций:
  * ```-n```: Отображает номера портов и IP-адреса в числовом формате, а не в виде имен (не выполняет DNS-резолюцию).
  * ```-t```: Отображает только TCP-соединения.
  * ```-l```: Отображает только слушающие порты.
  * ```-p```: Отображает информацию о процессах, связанных с соединениями и портами.
Т.е. команда покажет все активные TCP-соединения, а также все слушающие порты на компьютере, включая их номера и процессы, которые их используют. Это может быть полезно, например, для определения, какие приложения или службы прослушивают определенные порты на вашем сервере.  
* 

# 6. Средства управления задачами в bash  
Процессы по умолчанию запускаются в активном режиме, то есть на переднем плане.  
**Для управления процессами в терминале используются следующие комбинации клавиш:**  
* ```Ctrl + C```: прервать выполнение процесса.
* ```Ctrl + D```: завершить процесс ввода (может также привести к завершению сессии, если введено в пустой строке).
* ```Ctrl + Z```: отправить процесс в фоновый режим.
* ```Ctrl + S```, ```Ctrl + Q```: приостановить и возобновить вывод на терминале.
  
**Для управления задачами в фоне используются следующие команды:**  
* ```jobs```: просмотреть список задач в фоне.
* ```fg %<id>```: вернуть задачу с указанным идентификатором в передний план.  

Планирование выполнения задач в будущем можно осуществлять с использованием утилиты ```at``` (также используются вспомогательные утилиты ```atq``` / ```atrm```).  
**Вот краткое описание каждой из утилит:**  
* ```at```: Утилита **at** предназначена для назначения выполнения задачи (команды) в определенное время в будущем. Вы указываете время выполнения, и команда будет выполнена в указанный момент. Пример использования: ```at -f script.sh now + 1 hour``` (запуск выполнения скрипта script.sh через 1 час от текущего момента).
* ```atq```: Команда **atq** используется для просмотра очереди задач, которые были поставлены в планировщик задач **at**. Она отображает список задач в ожидании выполнения, указывая их идентификаторы. Пример использования: ```atq``` (просмотр списка задач в очереди с их идентификаторами).
* ```atrm```: Утилита **atrm** используется для удаления задач из очереди. Вы указываете идентификатор задачи, и она будет удалена из очереди. Пример использования: ```atrm 2 3 4``` (удаление задач с идентификаторами 2, 3 и 4 из очереди).  
